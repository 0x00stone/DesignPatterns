# Adapter *
当想要使现有的类与其他的接口兼容，或者提供一个统一的接口以供不同的实现类使用时，使用Adapter模式。

+ 需要使用现有类的功能，而这些类的接口不符合当前系统的接口标准。
+ 需要创建一个可以透明地与多个不同的客户端或离散系统互操作的重用类。

# Bridge
当希望将抽象与其实现分离, 以便两者可以独立变化时，使用Bridge模式。

+ 不希望在抽象和实现二者之间有固定的绑定关系，如实现可能在运行时切换。
+ 类的抽象以及其实现都应该可以通过生成子类的方式独立地扩展。

# Composite
当需要表示对象的部分-整体层次结构时，使用Composite模式。它可以使你对单个对象和组合对象的操作具有一致性。

+ 希望客户端可以忽略组合对象与单个对象的差异。
+ 在有树形结构的场合，用以表示整体与部分的关系。

# Decorator
当不通过子类化的方式来扩充对象的功能，而是希望在运行时添加职责时，使用Decorator模式。

+ 当系统需要新功能时，为避免使用大量子类来扩展对象功能。
+ 当需要动态地给一个对象添加功能，这些功能可以再动态地撤销。

# Facade
当需要提供一个简单的界面以隐藏复杂的系统，如一组不相关的类、一个复杂的类库或框架时，使用Facade模式。

+ 提供一个简单的或层次化的入口点去访问子系统。
+ 当需要解耦一个复杂系统以增加子系统的独立性和可移植性。

# Flyweight
当有大量相似对象，想要减少存储开销，进行内存共享时，使用Flyweight模式。

+ 当程序需要大量对象，这些对象有许多共同的特性，从而引入许多细粒度的对象来表示。
+ 当由于使用了大量的对象，造成很大的存储开销时。

# Proxy *
当需要一个替身或占位符来代表一个真实对象进行访问或控制时，使用Proxy模式。

+ 当需要为一个对象提供一个替代者或占位符以访问它，例如远程代理（Remote Proxies）、虚拟代理（Virtual Proxies）或保护代理（Protection Proxies）。
+ 当需要添加一些管理操作，但不想改变真实对象的类。
